RELATÓRIO - LAB 04

Gabriel Valente – 2310488
Gabriel Emile – 2220498

Exercício 1) Comunicação Pai-Filho via Pipe

-- ARQUIVO --

ex1.c: Programa que cria um processo filho e estabelece uma comunicação unidirecional com o processo pai através de um pipe. O pai escreve uma mensagem no pipe, e o filho a lê e exibe na tela.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char* argv[]) {
    int pid;
    int fd[2]; // fd[0] leitura, fd[1] escrita
    int readDataSize, writtenDataSize;

    
    char writeBuffer[] = "mensagem do pai pro filho"; 
    int bufferSize = strlen(writeBuffer) + 1;
    char* readBuffer = (char*)malloc(bufferSize);

    if (pipe(fd) < 0) {
        perror("failed to open pipe");
        exit(-1);
    }

    pid = fork();

    if (pid < 0) {
        perror("failed to fork");
        exit(1);
    }
    else if (pid > 0){ //pai
        close(fd[0]); // pai não lê
        writtenDataSize = write(fd[1], writeBuffer, bufferSize);
        printf("[pai] %d dados escritos\n", writtenDataSize);
    }
    else { // filho
        close(fd[1]); // filho não escreve
        readDataSize = read(fd[0], readBuffer, bufferSize);
        printf("[filho] %d dados lidos: %s\n", readDataSize, readBuffer);
    }

    return 0;
}

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o ex1 ex1.c
./ex1

-- OUTPUT --

[pai] 28 dados escritos
[filho] 28 dados lidos: mensagem do pai pro filho

-- ANÁLISE --

O programa demonstra o uso básico de pipes para comunicação entre processos.
1.  `pipe(fd)`: Cria um canal de comunicação anônimo, retornando dois descritores de arquivo: `fd[0]` para leitura e `fd[1]` para escrita.
2.  `fork()`: Cria um processo filho. Ambos, pai e filho, herdam os descritores de arquivo do pipe.
3.  Controle de Acesso: Para uma comunicação unidirecional, cada processo fecha a extremidade do pipe que não utilizará. O pai fecha `fd[0]` (leitura) e o filho fecha `fd[1]` (escrita).
4.  Comunicação: O pai usa `write()` para enviar dados para `fd[1]`, enquanto o filho usa `read()` para receber dados de `fd[0]`. O filho bloqueia a execução até que haja dados para serem lidos no pipe.

Exercício 2) Redirecionamento de Entrada e Saída

-- ARQUIVO --

ex2.c: Programa que manipula descritores de arquivo para redirecionar a entrada padrão (stdin) para ler de um arquivo `entrada.txt` e a saída padrão (stdout) para escrever em `saida.txt`.

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main(int argc, char* argv[]) {
    int fd_in; /* descritor a ser duplicado */
    int fd_out; /* descritor a ser duplicado */
    int retdup1; /* valor de retorno de dup */
    int retdup2; /* valor de retorno de dup */

    if ((fd_in = open("entrada.txt", O_RDONLY)) == -1) {
        perror("failed to open entrada.txt");
        exit(1);
    }

    if ((fd_out = open("saida.txt", O_CREAT | O_WRONLY| O_TRUNC)) == -1) {
        perror("failed to open saida.txt");
        exit(1);
    }

    close(0); /* fechamento da entrada stdin */
    close(1); /* fechamento da saída stdout */
    
    if ((retdup1 = dup(fd_in)) == -1) { /* duplicacao de stdin (menor descritor fechado) */
        perror("failed to dup()");
        exit(2);
    }

    if ((retdup2 = dup(fd_out)) == -1) {
        perror("failed to dup");
        exit(3);
    }

    printf("valor de retorno de dup(): %d \n", retdup1);
    printf("valor de retorno de dup2(): %d \n", retdup2); 
    printf("a seguir, conteudo do stdin...\n");

    char buffer[256];
    while (fgets(buffer, sizeof(buffer), stdin) != NULL) {
        // A função fputs escreve a string em um stream de saída.
        // Usamos stdout, que agora aponta para "saida.txt".
        fputs(buffer, stdout);
    }

    close(fd_in);
    close(fd_out);

    return 0;
}

entrada.txt: 

***#############################***
***#####******************######***
***#############################***
|||  teste 1, 2, 3, ...         |||
|||  conteudo da entrada        |||
|||  redirecionado com sucesso  |||
***#############################***
***#####******************######***
***#############################***

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o ex2 ex2.c
./ex2

(É necessário ter o arquivo `entrada.txt` no mesmo diretório)

-- OUTPUT --

O programa não gera saída no terminal. O resultado é escrito no arquivo `saida.txt`:

valor de retorno de dup(): 0 
valor de retorno de dup2(): 1 
a seguir, conteudo do stdin...
***#############################***
***#####******************######***
***#############################***
|||  teste 1, 2, 3, ...         |||
|||  conteudo da entrada        |||
|||  redirecionado com sucesso  |||
***#############################***
***#####******************######***
***#############################***

-- ANÁLISE --

Este exercício demonstra o redirecionamento de I/O a um nível fundamental, sem usar `fopen`.
1.  `open()`: O programa primeiro obtém descritores de arquivo para `entrada.txt` (leitura) e `saida.txt` (escrita).
2.  `close()` e `dup()`: O núcleo do programa. Ele fecha os descritores padrão `0` (stdin) e `1` (stdout). A chamada `dup(fd_in)` então duplica o descritor do arquivo de entrada, e como o `0` é o primeiro descritor livre, ele é reutilizado para apontar para `entrada.txt`. O mesmo ocorre com `dup(fd_out)`, que ocupa a posição `1`.
3.  Execução Transparente: A lógica principal do programa (o loop com `fgets` e `fputs`) continua a usar `stdin` e `stdout` normalmente. No entanto, por baixo dos panos, o sistema operacional agora lê de `entrada.txt` e escreve em `saida.txt` devido ao redirecionamento.

Exercício 3) Simulação de Pipe da Shell (ps | wc)

-- ARQUIVO --

shell.c: Programa que simula o comportamento do pipe (`|`) no shell do Unix. Ele cria dois processos filhos e um pipe para conectar a saída padrão do primeiro (`ps`) à entrada padrão do segundo (`wc`).

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>

#define BUFFER_SIZE 256

int main(int argc, char* argv[]) {
    int fd[2];

    if (pipe(fd) < 0) {
        perror("failed to open pipe");
        exit(-1);
    }

    int pid_1, pid_2;

    pid_1 = fork();

    if (pid_1 < 0) {
        perror("failed to fork");
        exit(1);
    }

    if (pid_1 == 0) {
        // filho 1 roda o comando ps (process status)
        close(fd[0]); // apenas escreve
        dup2(fd[1], 1);
        execlp("ps", "ps", NULL);
    }
    
    pid_2 = fork();

    if (pid_2 == 0) {
        // filho 2 roda o comando wc (word count), recebe o stdout da execução do filho 1
        close(fd[1]); // apenas lê
        waitpid(pid_1, NULL, 0);
        dup2(fd[0], 0);
        
        execlp("wc", "wc", NULL);
    }

    close(fd[0]);
    close(fd[1]);
    
    waitpid(-1, NULL, 0);

    return 0;
}

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o shell shell.c
./shell

-- OUTPUT --

(Os números variam a cada execução)
      5       20      151

-- ANÁLISE --

Este programa combina os conceitos de pipes, processos e redirecionamento para recriar uma funcionalidade central do shell.
1.  `pipe()` e `fork()`: O pai cria um pipe e depois dois processos filhos.
2.  Filho 1 (`ps`): Este processo fechará a ponta de leitura do pipe (`fd[0]`). Ele usa `dup2(fd[1], 1)` para fazer com que sua saída padrão (`stdout`, descritor 1) aponte para a ponta de escrita do pipe. Quando `execlp("ps", ...)` é chamado, a saída do comando `ps` é enviada para o pipe em vez da tela.
3.  Filho 2 (`wc`): Este processo fecha a ponta de escrita do pipe (`fd[1]`). Ele usa `dup2(fd[0], 0)` para que sua entrada padrão (`stdin`, descritor 0) leia os dados da ponta de leitura do pipe. Ao executar `execlp("wc", ...)` , o `wc` processa os dados que vêm do pipe como se tivessem sido digitados no teclado.
4.  Papel do Pai: É crucial que o processo pai feche *ambas* as extremidades do pipe (`fd[0]` e `fd[1]`). Se o pai não fechar a ponta de escrita (`fd[1]`), o `wc` (filho 2) nunca receberá o sinal de "fim de arquivo" (EOF) e ficará bloqueado indefinidamente, mesmo após o `ps` (filho 1) terminar.

Exercício 4) Condição de Corrida: Um Escritor e Dois Leitores

-- ARQUIVO --

ex4.c: Programa que cria um processo escritor e dois processos leitores que compartilham o mesmo pipe. O objetivo é demonstrar a condição de corrida (*race condition*), onde os leitores competem pelos dados escritos no pipe de forma não determinística.

#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

#define MESSAGE_SIZE 2
#define DELTA_T 1

int main(int argc, char* argv[]) {
    int fd[2];
    
    if (pipe(fd) < 0) {
        perror("failed to pipe");
    }

    int w_sleep = DELTA_T, r_sleep = 2*w_sleep;
    int pid_leitor1, pid_leitor2;
    char buff1[MESSAGE_SIZE], buff2[MESSAGE_SIZE]; 

    const char message1[] = "A";
    const char message2[] = "B";

    int contador = 5;

    pid_leitor1 = fork();

    if (pid_leitor1 < 0) {
        perror("failed to fork 1");
        exit(1);
    }

    if (pid_leitor1 == 0) {
        // filho leitor 1
        close(fd[1]); // não lê apenas escreve
        while (contador) {
            sleep(r_sleep);
            read(fd[0], buff1, MESSAGE_SIZE);
            fprintf(stdout, "[leitor 1] filho 1 leu: %s\n", buff1);
            contador--;    
        }
        exit(3);
    }

    pid_leitor2 = fork();

    if (pid_leitor2 < 0) {
        perror("failed to fork 2");
        exit(2);
    }

    if (pid_leitor2 == 0) {
        // filho leitor 2
        close(fd[1]); // não lê apenas escreve
        while (contador) {
            sleep(r_sleep);
            read(fd[0], buff2, MESSAGE_SIZE);
            fprintf(stdout, "[leitor 2] filho 2 leu: %s\n", buff2);        
            contador--;    
        }
        exit(3);
    }

    close(fd[0]); // apenas escreve

    while (contador) {
        sleep(w_sleep);
        write(fd[1], message1, MESSAGE_SIZE);
        fprintf(stdout, "[escritor] pai escreveu\n");        
        write(fd[1], message2, MESSAGE_SIZE);         
        fprintf(stdout, "[escritor] pai escreveu\n");        
        contador--;    
    }
    sleep(r_sleep); // garantir última execução dos filhos;

    close(fd[1]);
    waitpid(-1, NULL, 0);

    return 0;
}

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o ex4 ex4.c
./ex4

-- OUTPUT --

(A saída é imprevisível e varia a cada execução)
$ ./ex4
[escritor] pai escreveu
[escritor] pai escreveu
[leitor 2] filho 2 leu: B
[leitor 1] filho 1 leu: A
[escritor] pai escreveu
[escritor] pai escreveu
[escritor] pai escreveu
[escritor] pai escreveu
[leitor 1] filho 1 leu: A
[leitor 2] filho 2 leu: B
[escritor] pai escreveu
[escritor] pai escreveu
[escritor] pai escreveu
[escritor] pai escreveu
[leitor 2] filho 2 leu: A
[leitor 1] filho 1 leu: B
[leitor 1] filho 1 leu: A
[leitor 2] filho 2 leu: B
[leitor 2] filho 2 leu: A
[leitor 1] filho 1 leu: B

-- ANÁLISE --

Este experimento ilustra um problema clássico de concorrência.
1.  Recurso Compartilhado: O pipe (`fd[0]`) é um recurso compartilhado por dois processos leitores. Ambos estão bloqueados na chamada `read()`, esperando por dados.
2.  Condição de Corrida: Quando o pai escreve no pipe, o kernel do sistema operacional acorda os processos que esperam por dados. No entanto, não há garantia de qual leitor será escalonado primeiro para executar o `read()`. O primeiro que executar, "consome" os dados da fila do pipe.
3.  Comportamento Não Determinístico: O output demonstra claramente essa imprevisibilidade. Às vezes o `leitor 1` lê a mensagem 'A' e o `leitor 2` a 'B', mas em outros momentos a ordem se inverte. Um leitor pode até mesmo ler várias mensagens seguidas se o escalonador do SO o favorecer. As chamadas `sleep()` apenas influenciam o tempo, mas não sincronizam os processos, tornando a condição de corrida visível.