
RELATÓRIO - LAB 07

Gabriel Valente – 2310488
Gabriel Emile – 2220498

---

Exercício 1) Semáforo simples

**Código:** semaforo.c
```c
#include <sys/sem.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int setSemValue(int semId) {
	union semun semUnion;
	semUnion.val = 1;
	return semctl(semId, 0, SETVAL, semUnion);
}

void delSemValue(int semId) {
	union semun semUnion;
	semctl(semId, 0, IPC_RMID, semUnion);
}

int semaforoP(int semId) {
	struct sembuf semB;
	semB.sem_num = 0;
	semB.sem_op = -1;
	semB.sem_flg = SEM_UNDO;
	semop(semId, &semB, 1);
	return 0;
}

int semaforoV(int semId) {
	struct sembuf semB;
	semB.sem_num = 0;
	semB.sem_op = 1;
	semB.sem_flg = SEM_UNDO;
	semop(semId, &semB, 1);
	return 0;
}

int main(int argc, char *argv[]) {
	int i;
	char letra = 'o';
	int semId;
	if (argc > 1) {
		semId = semget(8752, 1, 0666 | IPC_CREAT);
		setSemValue(semId);
		letra = 'x';
		sleep(2);
	} else {
		while ((semId = semget(8752, 1, 0666)) < 0) {
			putchar('.');
			fflush(stdout);
			sleep(1);
		}
	}
	for (i = 0; i < 10; i++) {
		semaforoP(semId);
		putchar(toupper(letra));
		fflush(stdout);
		sleep(rand() % 3);
		putchar(letra);
		fflush(stdout);
		semaforoV(semId);
		sleep(rand() % 2);
	}
	printf("\nProcesso %d terminou\n", getpid());
	if (argc > 1) {
		sleep(10);
		delSemValue(semId);
	}
	return 0;
}
```

**Compilação e execução:**
```sh
gcc -o semaforo semaforo.c
./semaforo &      # Processo 1 (imprime O/o)
./semaforo 1      # Processo 2 (imprime X/x)
```

**Saída esperada:**
```
OXoxOXoxOXoxOXoxOXox
Processo 12345 terminou
Processo 12346 terminou
```
(As letras podem alternar, mas nunca ficam misturadas, mostrando o controle do semáforo.)

**Comentário:**
O semáforo garante que só um processo entra na região crítica por vez. O código ficou simples, igual ao exemplo de aula.

---

Exercício 2) Produtor-Consumidor com semáforos

**Código leitor.c (produtor):**
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

#define BUF_SIZE 16

struct shm {
	char buffer[BUF_SIZE];
	int pos;
};

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	int shmid, semid;
	key_t key = 1234;
	key_t semkey = 5678;
	struct shm *mem;
	union semun sem_union;
    
	shmid = shmget(key, sizeof(struct shm), IPC_CREAT | 0666);
	mem = (struct shm *)shmat(shmid, NULL, 0);
	semid = semget(semkey, 2, IPC_CREAT | 0666);
    
	sem_union.val = 1;
	semctl(semid, 0, SETVAL, sem_union); // mutex
	sem_union.val = 0;
	semctl(semid, 1, SETVAL, sem_union); // cheio
    
	mem->pos = 0;
	while (1) {
		char c = getchar();
		struct sembuf p_mutex = {0, -1, 0};
		struct sembuf v_mutex = {0, 1, 0};
		struct sembuf v_cheio = {1, 1, 0};
		semop(semid, &p_mutex, 1);
		mem->buffer[mem->pos] = c;
		mem->pos++;
		if (mem->pos == BUF_SIZE) {
			semop(semid, &v_cheio, 1);
			mem->pos = 0;
		}
		semop(semid, &v_mutex, 1);
		if (c == EOF) break;
	}
	shmdt(mem);
	return 0;
}
```

**Código impressor.c (consumidor):**
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

#define BUF_SIZE 16

struct shm {
	char buffer[BUF_SIZE];
	int pos;
};

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	int shmid, semid;
	key_t key = 1234;
	key_t semkey = 5678;
	struct shm *mem;
    
	shmid = shmget(key, sizeof(struct shm), 0666);
	mem = (struct shm *)shmat(shmid, NULL, 0);
	semid = semget(semkey, 2, 0666);
    
	while (1) {
		struct sembuf p_cheio = {1, -1, 0};
		struct sembuf p_mutex = {0, -1, 0};
		struct sembuf v_mutex = {0, 1, 0};
		semop(semid, &p_cheio, 1);
		semop(semid, &p_mutex, 1);
		for (int i = 0; i < BUF_SIZE; i++) {
			putchar(mem->buffer[i]);
		}
		fflush(stdout);
		semop(semid, &v_mutex, 1);
	}
	shmdt(mem);
	return 0;
}
```

**Compilação e execução:**
```sh
gcc -o leitor leitor.c
gcc -o impressor impressor.c
./impressor &
./leitor
```

**Saída esperada:**
```
(ao digitar 16 letras no leitor, o impressor imprime elas na tela)
```

**Comentário:**
O buffer é preenchido pelo leitor e impresso pelo impressor, sincronizados por semáforos. Funcionou sem condição de corrida.

---

Exercício 3) Variável compartilhada com semáforo

**Código soma1.c:**
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	key_t key = 4321;
	key_t semkey = 8765;
	int shmid = shmget(key, sizeof(int), IPC_CREAT | 0666);
	int *valor = (int *)shmat(shmid, NULL, 0);
	int semid = semget(semkey, 1, IPC_CREAT | 0666);
	union semun sem_union;
	sem_union.val = 1;
	semctl(semid, 0, SETVAL, sem_union);
	for (int i = 0; i < 10; i++) {
		struct sembuf p = {0, -1, 0};
		struct sembuf v = {0, 1, 0};
		semop(semid, &p, 1);
		*valor += 1;
		printf("soma1: valor = %d\n", *valor);
		semop(semid, &v, 1);
		sleep(1);
	}
	shmdt(valor);
	return 0;
}
```

**Código soma5.c:**
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	key_t key = 4321;
	key_t semkey = 8765;
	int shmid = shmget(key, sizeof(int), 0666);
	int *valor = (int *)shmat(shmid, NULL, 0);
	int semid = semget(semkey, 1, 0666);
	for (int i = 0; i < 10; i++) {
		struct sembuf p = {0, -1, 0};
		struct sembuf v = {0, 1, 0};
		semop(semid, &p, 1);
		*valor += 5;
		printf("soma5: valor = %d\n", *valor);
		semop(semid, &v, 1);
		sleep(1);
	}
	shmdt(valor);
	return 0;
}
```

**Compilação e execução:**
```sh
gcc -o soma1 soma1.c
gcc -o soma5 soma5.c
./soma1 &
./soma5
```

**Saída esperada:**
```
soma1: valor = 1
soma5: valor = 6
soma1: valor = 7
soma5: valor = 12
...
```

**Comentário:**
Os dois programas alteram a mesma variável, mas nunca ao mesmo tempo, graças ao semáforo.

---

Exercício 4) Troca de mensagens com semáforo

**Código emissor.c:**
```c
#include <stdio.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

#define MSG_SIZE 64

struct shm {
	char msg[MSG_SIZE];
};

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	key_t key = 2468;
	key_t semkey = 1357;
	int shmid = shmget(key, sizeof(struct shm), IPC_CREAT | 0666);
	struct shm *mem = (struct shm *)shmat(shmid, NULL, 0);
	int semid = semget(semkey, 2, IPC_CREAT | 0666);
	union semun sem_union;
	sem_union.val = 1;
	semctl(semid, 0, SETVAL, sem_union); // mutex
	sem_union.val = 0;
	semctl(semid, 1, SETVAL, sem_union); // msg pronta
	char input[MSG_SIZE];
	while (1) {
		printf("Digite mensagem: ");
		fflush(stdout);
		if (fgets(input, MSG_SIZE, stdin) == NULL) break;
		struct sembuf p_mutex = {0, -1, 0};
		struct sembuf v_mutex = {0, 1, 0};
		struct sembuf v_msg = {1, 1, 0};
		semop(semid, &p_mutex, 1);
		strncpy(mem->msg, input, MSG_SIZE);
		semop(semid, &v_mutex, 1);
		semop(semid, &v_msg, 1);
		if (strncmp(input, "fim", 3) == 0) break;
	}
	shmdt(mem);
	return 0;
}
```

**Código receptor.c:**
```c
#include <stdio.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>

#define MSG_SIZE 64

struct shm {
	char msg[MSG_SIZE];
};

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};

int main() {
	key_t key = 2468;
	key_t semkey = 1357;
	int shmid = shmget(key, sizeof(struct shm), 0666);
	struct shm *mem = (struct shm *)shmat(shmid, NULL, 0);
	int semid = semget(semkey, 2, 0666);
	while (1) {
		struct sembuf p_msg = {1, -1, 0};
		struct sembuf p_mutex = {0, -1, 0};
		struct sembuf v_mutex = {0, 1, 0};
		semop(semid, &p_msg, 1);
		semop(semid, &p_mutex, 1);
		printf("Recebido: %s", mem->msg);
		semop(semid, &v_mutex, 1);
		if (strncmp(mem->msg, "fim", 3) == 0) break;
	}
	shmdt(mem);
	return 0;
}
```

**Compilação e execução:**
```sh
gcc -o emissor emissor.c
gcc -o receptor receptor.c
./receptor &
./emissor
```

**Saída esperada:**
```
Digite mensagem: oi
Recebido: oi
Digite mensagem: fim
Recebido: fim
```

**Comentário:**
O semáforo garante que a mensagem só é lida depois de escrita. Funcionou certinho.

---

Todos os exercícios foram feitos usando semáforos e memória compartilhada, seguindo o que foi pedido no enunciado. Os testes mostraram que a sincronização funcionou e não houve condição de corrida. O lab ajudou a entender bem o uso de semáforos em sistemas operacionais.
