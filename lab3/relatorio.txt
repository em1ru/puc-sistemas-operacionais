RELATÓRIO - LAB 03

Gabriel Valente – 2310488
Gabriel Emile – 2220498

Exercício 1) Programa ctrl-c.c

-- ARQUIVO --

ctrl-c.c: Programa que instala tratadores para os sinais SIGINT (Ctrl-C) e SIGQUIT (Ctrl-\).

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o ctrl-c ctrl-c.c
./ctrl-c

Durante a execução:

Ao apertar Ctrl-C, o programa não termina e apenas imprime a mensagem configurada no tratador.

Ao apertar Ctrl-\, o programa chama o tratador de SIGQUIT, imprime a mensagem de encerramento e termina.

-- OUTPUT --

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
Você pressionou Ctrl-C (2)
Você pressionou Ctrl-C (2)
Terminando o processo...

-- TESTE SEM OS signal() --
Depois de remover as linhas com signal(SIGINT, intHandler); e signal(SIGQUIT, quitHandler);, o comportamento mudou:

Ctrl-C finaliza o processo imediatamente (tratamento padrão do sistema).

Ctrl-\ também finaliza o processo, mas sem imprimir nada (tratamento padrão de SIGQUIT).

-- ANÁLISE --

Esse experimento mostrou que ao instalar tratadores com signal() conseguimos controlar o que acontece quando sinais são enviados ao processo.

Com tratadores: o programa ignora o comportamento padrão e executa o código definido nas funções (intHandler e quitHandler).

Sem tratadores: o sistema operacional aplica a ação default dos sinais (terminar o processo).

Exercício 2) Interceptar SIGKILL

-- ARQUIVO --

sigkill.c: Programa que tenta instalar um tratador para o sinal SIGKILL.

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o sigkill sigkill.c
./sigkill

No terminal aparece a mensagem informando que não foi possível instalar o tratador.
Mesmo assim, deixamos o programa rodando em loop infinito e tentamos finalizar o processo com:

kill -9 <pid>

O processo foi encerrado na hora, sem imprimir nada do handler.

-- OUTPUT --

Não foi possível instalar tratador para SIGKILL.
Processo rodando... tente matar com kill -9 <pid>
[processo termina imediatamente]

-- ANÁLISE --

O teste mostrou que não é possível capturar, ignorar ou tratar SIGKILL.
Esse sinal é reservado pelo kernel para garantir que o processo realmente será terminado, sem chance de recuperação.
Apenas sinais como SIGINT, SIGQUIT, SIGUSR1, etc., podem ter tratadores definidos.

Exercício 3) Programa filhocidio.c

-- ARQUIVOS --

filhocidio.c: Programa que executa um outro a partir de um filho e espera determinado tempo para que o programa filho termine. 
Se o programa filho não terminar, o pai mata o filho. 

sleep5.c e sleep15.c: Programas simples que serão executados pelos filhos criados em filhocidio.c, cujos objetivos são apenas imprimir mensagens no console antes e depois de um sleep de 5 ou de 15 segundos. 

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o filhocidio filhocidio.c
gcc -o sleep5 sleep5.c
gcc -o sleep15 sleep15.c
./filhocidio 10 ./sleep5
./filhocidio 10 ./sleep15

-- OUTPUT --

$ ./filhocidio 10 ./sleep5
    indo dormir...
    Acordei!
    Child 213 terminated within 10 seconds com estado 0.
$ ./filhocidio 10 ./sleep15
    indo dormir...
    Program ./sleep15 exceeded limit of 10 seconds!
    Child 215 terminated within 10 seconds com estado 9.

-- ANÁLISE --

O código demonstra uma relação de controle entre um processo pai e um filho, 
onde o resultado depende de uma "corrida" contra o tempo. Se o processo filho
consegue completar sua tarefa e terminar antes do tempo limite definido pelo pai, 
o sistema reporta uma saída bem-sucedida com estado 0. Contudo, se o tempo do pai
se esgota primeiro, ele encerra o filho à força através de um sinal SIGKILL,
resultando em uma saída com estado 9, indicando que o filho foi "assassinado" por
exceder o prazo e não conseguiu finalizar sua execução. Como o programa sleep15 leva um 
tempo de 15 segundos > 10 segundos, ele é finalizado antes de completar sua execução, 
não havendo a impressão na tela do segundo printf. Analogamente, como 5 < 10, o programa sleep5
conclui sua execução a tempo antes de ser interrompido pelo pai, sendo portanto realizado o printf 
pós sleep. 

Claro! Perfeito. Seguindo a estrutura do seu relatório, aqui está a seção para o exercício que acabamos de desenvolver.

Exercício 4) Programa alternador.c

-- ARQUIVO --
alternador.c: Programa que demonstra o controle de processos usando sinais. O processo pai cria dois processos filhos, cada um executando um loop infinito que imprime mensagens na tela. O pai atua como um escalonador simples, utilizando os sinais SIGSTOP e SIGCONT para alternar a execução entre os dois filhos. Após 10 trocas de contexto, o pai encerra ambos os filhos com o sinal SIGKILL.

-- COMPILAÇÃO E EXECUÇÃO --
gcc -o alternador alternador.c
./alternador

Durante a execução, será possível observar blocos de mensagens do "filho 0" e do "filho 1" aparecendo de forma alternada no terminal. Entre cada bloco, o processo pai imprime uma mensagem indicando qual filho está parando e qual está continuando, tornando a troca de contexto explícita.

-- OUTPUT --
[pai] filho 0 (PID: 429) criado.
filho 0 vivo!
[pai] filho 1 (PID: 430) criado.
filho 1 vivo!
filho 0 vivo!
[PAI] Pausando ambos os filhos para sincronizar...
[PAI] Começando troca de contexto...
[PAI] Filho 0 acordado, filho 1 parado

filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (0)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (1)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (2)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (3)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (4)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (5)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (6)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (7)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (8)

filho 1 vivo!
filho 1 vivo!

filho 1 vivo!
[PAI] Parando filho 1, continuando filho 0... (9)

filho 0 vivo!

[PAI] Fim das trocas. Matando os filhos.
[PAI] Filho 0 (PID: 429) morto          AAAAAAAAAAAAAA (gritos ao fundo).
[PAI] Filho 1 (PID: 430) morto.
[PAI] Processo encerrado.

-- ANÁLISE --
Este experimento demonstra o poder dos sinais para o controle e gerenciamento de processos. Através dos sinais SIGSTOP e SIGCONT, um processo pai pode orquestrar a execução de seus filhos de maneira precisa, funcionando como um escalonador externo rudimentar.

A estratégia principal foi:

Criação e Pausa Imediata: O pai cria os filhos e, para garantir o controle total e um ponto de partida sincronizado, envia SIGSTOP para ambos imediatamente. Isso os coloca em um estado "Parado" (Stopped) antes que possam executar seu loop.

Alternância Controlada: O pai então entra em um loop onde, a cada iteração, ele "acorda" um filho com SIGCONT e "adormece" o outro com SIGSTOP. Isso garante que apenas um filho consuma recursos da CPU por vez.

Término Forçado: Ao final, o pai usa SIGKILL (kill -9), confirmando o que vimos no Exercício 2: um sinal que não pode ser ignorado e que garante o término imediato dos processos filhos.

O resultado é uma simulação clara de troca de contexto, um conceito fundamental em sistemas operacionais, implementado manualmente através do sistema de sinais do Unix.