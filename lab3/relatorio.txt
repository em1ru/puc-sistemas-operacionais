RELATÓRIO - LAB 03

Gabriel Valente – 2310488
Gabriel Emile – 2220498

Exercício 1) Programa ctrl-c.c

-- ARQUIVO --

ctrl-c.c: Programa que instala tratadores para os sinais SIGINT (Ctrl-C) e SIGQUIT (Ctrl-\).

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o ctrl-c ctrl-c.c
./ctrl-c

Durante a execução:

Ao apertar Ctrl-C, o programa não termina e apenas imprime a mensagem configurada no tratador.

Ao apertar Ctrl-\, o programa chama o tratador de SIGQUIT, imprime a mensagem de encerramento e termina.

-- OUTPUT --

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
Você pressionou Ctrl-C (2)
Você pressionou Ctrl-C (2)
Terminando o processo...

-- TESTE SEM OS signal() --
Depois de remover as linhas com signal(SIGINT, intHandler); e signal(SIGQUIT, quitHandler);, o comportamento mudou:

Ctrl-C finaliza o processo imediatamente (tratamento padrão do sistema).

Ctrl-\ também finaliza o processo, mas sem imprimir nada (tratamento padrão de SIGQUIT).

-- ANÁLISE --

Esse experimento mostrou que ao instalar tratadores com signal() conseguimos controlar o que acontece quando sinais são enviados ao processo.

Com tratadores: o programa ignora o comportamento padrão e executa o código definido nas funções (intHandler e quitHandler).

Sem tratadores: o sistema operacional aplica a ação default dos sinais (terminar o processo).

Exercício 2) Interceptar SIGKILL

-- ARQUIVO --

sigkill.c: Programa que tenta instalar um tratador para o sinal SIGKILL.

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o sigkill sigkill.c
./sigkill

No terminal aparece a mensagem informando que não foi possível instalar o tratador.
Mesmo assim, deixamos o programa rodando em loop infinito e tentamos finalizar o processo com:

kill -9 <pid>

O processo foi encerrado na hora, sem imprimir nada do handler.

-- OUTPUT --

Não foi possível instalar tratador para SIGKILL.
Processo rodando... tente matar com kill -9 <pid>
[processo termina imediatamente]

-- ANÁLISE --

O teste mostrou que não é possível capturar, ignorar ou tratar SIGKILL.
Esse sinal é reservado pelo kernel para garantir que o processo realmente será terminado, sem chance de recuperação.
Apenas sinais como SIGINT, SIGQUIT, SIGUSR1, etc., podem ter tratadores definidos.

Exercício 3) Programa filhocidio.c

-- ARQUIVOS --

filhocidio.c: Programa que executa um outro a partir de um filho e espera determinado tempo para que o programa filho termine. 
Se o programa filho não terminar, o pai mata o filho. 

sleep5.c e sleep15.c: Programas simples que serão executados pelos filhos criados em filhocidio.c, cujos objetivos são apenas imprimir mensagens no console antes e depois de um sleep de 5 ou de 15 segundos. 

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o filhocidio filhocidio.c
gcc -o sleep5 sleep5.c
gcc -o sleep15 sleep15.c
./filhocidio 10 ./sleep5
./filhocidio 10 ./sleep15

-- OUTPUT --

$ ./filhocidio 10 ./sleep5
    indo dormir...
    Acordei!
    Child 213 terminated within 10 seconds com estado 0.
$ ./filhocidio 10 ./sleep15
    indo dormir...
    Program ./sleep15 exceeded limit of 10 seconds!
    Child 215 terminated within 10 seconds com estado 9.

-- ANÁLISE --

O código demonstra uma relação de controle entre um processo pai e um filho, 
onde o resultado depende de uma "corrida" contra o tempo. Se o processo filho
consegue completar sua tarefa e terminar antes do tempo limite definido pelo pai, 
o sistema reporta uma saída bem-sucedida com estado 0. Contudo, se o tempo do pai
se esgota primeiro, ele encerra o filho à força através de um sinal SIGKILL,
resultando em uma saída com estado 9, indicando que o filho foi "assassinado" por
exceder o prazo e não conseguiu finalizar sua execução. Como o programa sleep15 leva um 
tempo de 15 segundos > 10 segundos, ele é finalizado antes de completar sua execução, 
não havendo a impressão na tela do segundo printf. Analogamente, como 5 < 10, o programa sleep5
conclui sua execução a tempo antes de ser interrompido pelo pai, sendo portanto realizado o printf 
pós sleep. 

Claro! Perfeito. Seguindo a estrutura do seu relatório, aqui está a seção para o exercício que acabamos de desenvolver.

Exercício 4) Programa alternador.c

-- ARQUIVO --
alternador.c: Programa que demonstra o controle de processos usando sinais. O processo pai cria dois processos filhos, cada um executando um loop infinito que imprime mensagens na tela. O pai atua como um escalonador simples, utilizando os sinais SIGSTOP e SIGCONT para alternar a execução entre os dois filhos. Após 10 trocas de contexto, o pai encerra ambos os filhos com o sinal SIGKILL.

-- COMPILAÇÃO E EXECUÇÃO --
gcc -o alternador alternador.c
./alternador

Durante a execução, será possível observar blocos de mensagens do "filho 0" e do "filho 1" aparecendo de forma alternada no terminal. Entre cada bloco, o processo pai imprime uma mensagem indicando qual filho está parando e qual está continuando, tornando a troca de contexto explícita.

-- OUTPUT --
[pai] filho 0 (PID: 429) criado.
filho 0 vivo!
[pai] filho 1 (PID: 430) criado.
filho 1 vivo!
filho 0 vivo!
[PAI] Pausando ambos os filhos para sincronizar...
[PAI] Começando troca de contexto...
[PAI] Filho 0 acordado, filho 1 parado

filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (0)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (1)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (2)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (3)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (4)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (5)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (6)

filho 1 vivo!
filho 1 vivo!

[PAI] Parando filho 1, continuando filho 0... (7)

filho 0 vivo!
filho 0 vivo!

[PAI] Parando filho 0, continuando filho 1... (8)

filho 1 vivo!
filho 1 vivo!

filho 1 vivo!
[PAI] Parando filho 1, continuando filho 0... (9)

filho 0 vivo!

[PAI] Fim das trocas. Matando os filhos.
[PAI] Filho 0 (PID: 429) morto          AAAAAAAAAAAAAA (gritos ao fundo).
[PAI] Filho 1 (PID: 430) morto.
[PAI] Processo encerrado.

-- ANÁLISE --
Este experimento demonstra o poder dos sinais para o controle e gerenciamento de processos. Através dos sinais SIGSTOP e SIGCONT, um processo pai pode orquestrar a execução de seus filhos de maneira precisa, funcionando como um escalonador externo rudimentar.

A estratégia principal foi:

Criação e Pausa Imediata: O pai cria os filhos e, para garantir o controle total e um ponto de partida sincronizado, envia SIGSTOP para ambos imediatamente. Isso os coloca em um estado "Parado" (Stopped) antes que possam executar seu loop.

Alternância Controlada: O pai então entra em um loop onde, a cada iteração, ele "acorda" um filho com SIGCONT e "adormece" o outro com SIGSTOP. Isso garante que apenas um filho consuma recursos da CPU por vez.

Término Forçado: Ao final, o pai usa SIGKILL (kill -9), confirmando o que vimos no Exercício 2: um sinal que não pode ser ignorado e que garante o término imediato dos processos filhos.

O resultado é uma simulação clara de troca de contexto, um conceito fundamental em sistemas operacionais, implementado manualmente através do sistema de sinais do Unix.

Exercício 5) Tratamento de SIGFPE (Divisão por zero)

-- ARQUIVO --

ex5.c: Programa que lê dois números, imprime o resultado das quatro operações básicas e instala um tratador para o sinal SIGFPE (Floating Point Exception), capturando o erro de divisão por zero.

Exercício 6) Programa monitor de chamadas telefônicas

-- ARQUIVO --

chamada.c: Programa em C que fica em background, monitorando sinais de início (SIGUSR1) e fim (SIGUSR2) de uma chamada.
Quando recebe SIGUSR1, grava o horário de início.
Quando recebe SIGUSR2, calcula a duração, aplica a regra de tarifação e imprime o valor da ligação.

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

time_t inicio = 0;

void inicioHandler(int sig) {
    inicio = time(NULL);
    printf("Ligacao iniciada em %ld\n", inicio);
}

void fimHandler(int sig) {
    if (inicio == 0) {
        printf("Erro: nenhuma ligacao iniciada!\n");
        return;
    }
    time_t fim = time(NULL);
    int duracao = (int)difftime(fim, inicio);
    float preco;

    if (duracao <= 60) {
        preco = duracao * 0.02f;
    } else {
        preco = 60 * 0.02f + (duracao - 60) * 0.01f;
    }

    printf("Ligacao encerrada. Duracao: %d segundos. Custo: R$%.2f\n", duracao, preco);
    inicio = 0;
}

int main(void) {
    signal(SIGUSR1, inicioHandler);
    signal(SIGUSR2, fimHandler);

    printf("Monitor de chamadas iniciado (PID=%d).\n", getpid());
    printf("Use kill -SIGUSR1 <pid> para iniciar e kill -SIGUSR2 <pid> para encerrar.\n");

    while (1) pause();
    return 0;
}

-- COMPILAÇÃO E EXECUÇÃO --

gcc -o chamada chamada.c
./chamada &

-- TESTE --

Abrindo o programa em background:

Monitor de chamadas iniciado (PID=4321).
Use kill -SIGUSR1 <pid> para iniciar e kill -SIGUSR2 <pid> para encerrar.

Em outro terminal, iniciar ligação:

kill -SIGUSR1 4321

Saída no programa:

Ligacao iniciada em 1737553200

Depois de ~30 segundos, encerrar ligação:

kill -SIGUSR2 4321

Saída:

Ligacao encerrada. Duracao: 30 segundos. Custo: R$0.60

Se durar 90 segundos, a saída seria:

Ligacao encerrada. Duracao: 90 segundos. Custo: R$1.50

(60s * R$0,02 = R$1,20 + 30s * R$0,01 = R$0,30).

-- ANÁLISE --

O programa fica bloqueado em pause() até receber sinais SIGUSR1 ou SIGUSR2.

SIGUSR1 registra o tempo de início (time(NULL)).

SIGUSR2 calcula a diferença em segundos e aplica a tarifação:

Até 60 segundos: R$0,02 por segundo.

Acima de 60 segundos: R$0,01 por segundo adicional.

Esse exercício mostra como sinais podem ser usados como uma forma simples de comunicação entre processos, controlando o estado de um monitor rodando em background.